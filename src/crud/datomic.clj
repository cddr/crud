(in-ns 'crud.resource)

(defn find-referrer [referrer refs]
  (first (filter #(= (:referrer %) referrer) refs)))

(defn find-entities [db params]
  "Find all entities in `db` where the predicates specified by `params` are true" 
  (let [build-predicate (fn [[k v]] ['?e k v])
        q {:find '[?e]
           :in '[$]
           :where (map build-predicate params)}]
    (map (partial d/entity db) (apply concat (d/q q db)))))

(defn branch? [v]
  (some #{(class v)} [clojure.lang.PersistentArrayMap clojure.lang.PersistentHashMap]))

(defn as-response [entity schema refs]
  "Walk `entity` using the specified `schema` to decide which attributes to traverse. Use refs to specify
which attributes are expected to be datomic refs. The values returned for those refs will be transformed
via the :as-response key of the corresponding ref"
  (letfn [(walk-entity [entity schema]
            (reduce (fn [m [schema-name schema-type]]
                      (if (branch? schema-type)
                        (merge m {schema-name (walk-entity (schema-name entity)
                                                           {schema-name schema-type})})
                        (merge m (if-let [ref (find-referrer schema-name refs)]
                                   {schema-name ((:as-response ref) entity)}
                                   {schema-name (schema-name entity)}))))
                    {}
                    schema))]
    (walk-entity entity (seq schema))))

;; (defrecord DatomicRepresentation [schema refs]
;;   liberator.representation/Representation
;;   (liberator.representation/as-response [this context]
;;     (as-response (::entity context) schema refs)))

(defn as-facts
  ([tmp-id object refs]
     "Generates datomic facts by recursively walking the specified map converting
(key val) -> [:db/add tmp-id attr val]

For any values that are themselves maps, we recur on the map and add a ref for
the current key"
     (reduce (fn [acc [k v]]
               (if (branch? v)
                 (into acc (let [ref-id (d/tempid :db.part/user)
                                 ret (concat [[:db/add tmp-id k ref-id]]
                                             (as-facts ref-id (into {} v)))]
                             ret))
                 (into acc [[:db/add tmp-id k (if-let [ref (find-referrer k refs)]
                                                (condp instance? v
                                                  datomic.db.DbId v
                                                  ((:as-lookup-ref ref) v))
                                                v)]])))
             []
             (seq object)))
  ([objects]
     (mapcat (fn [obj]
               (as-facts (d/tempid :db.part/user) obj []))
             objects)))

(defn apply-tx [c facts]
  "Apply a transaction against `c` using the facts generated by calling `as-facts` with `params`"
  @(d/transact c facts))

(def ^{:private true} type-map
  {Str                      :db.type/string
   Bool                     :db.type/boolean
   Long                     :db.type/long
   ;java.Math.BigInteger     :db.type/bigint
   Num                      :db.type/double
   Int                      :db.type/long
   Float                    :db.type/float
   Inst                     :db.type/instant

   URI                      :db.type/string})

(defn datomic-schema [schema uniqueness refs]
  "Generate datomic attributes for the specified resource.

If `uniqueness` is specified, it should be a hash where each key means
  the attribute with that name is marked as unique in datomic. The
  value can be used to determine the type of uniqueness. For details
  about the different types of uniqueness, refer to the datomic
  documentation which can be found at

http://docs.datomic.com/identity.html

If `refs` is specified, it should be a sequence of attributes which
represent references to other entities. For each ref, at attribute of type
:db.type/ref will be generated."
  (letfn [(generate-ref [k v]
            (merge (generate-attr k v)
                   {:db/valueType :db.type/ref}))
          
          (generate-attr [k v]
            (let [cardinality (if (vector? v)
                                :db.cardinality/many :db.cardinality/one)
                  value-type (get type-map v :db.type/string)]
              (merge
               {:db/id (d/tempid :db.part/db)
                :db/ident k
                :db/valueType value-type
                :db/cardinality cardinality
                :db.install/_attribute :db.part/db}
               (if-let [uniq (k uniqueness)] {:db/unique uniq} {}))))

          (reducer [acc [k v]]
            (cond
             (find-referrer k refs)
             (into acc [(generate-ref k v)])

             (branch? v)
             (into acc (conj (generate-attrs (into {} v))
                             ((:attr-factory dat/Ref) k)))

             :else
             (into acc [(generate-attr k v)])))
          
          (generate-attrs [schema]
            (reduce reducer [] (seq schema)))]
    (generate-attrs schema)))

