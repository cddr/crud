(ns crud.core
  "Maps datomic attribute definitions to prismatic schemata
and vice versa"
  (:require [datomic.api :as d]
            [schema.core :as s :refer [Str Num Inst Int Bool Keyword]]
            [schema.coerce :refer [coercer string-coercion-matcher]]
            [integrity.datomic :as dat]
            [compojure.core :as http]
            [compojure.route :as route]
            [liberator.core :as rest :refer [by-method]]
            [ring.util.response :as resp])
  (:import [java.net URL URI]))

(defmacro defentity [name & body]
  `(def ~name
     (merge {:name (clojure.string/lower-case (name '~name))}
            (hash-map ~@body))))

(defn find-referrer
  "Find the first referrer with the specified name in `refs`"
  [referrer refs]
  (first (filter #(= (:referrer %) referrer) refs)))

(defn find-entities
  "Find all entities in `db` where the predicates specified by `params` are true" 
  [db params]
  (let [build-predicate (fn [[k v]] ['?e k v])
        q {:find '[?e]
           :in '[$]
           :where (map build-predicate params)}]
    (map (partial d/entity db) (apply concat (d/q q db)))))

(defn branch?
  "Return true if `v` has sub-elements"
  [v]
  (some #{(class v)} [clojure.lang.PersistentArrayMap clojure.lang.PersistentHashMap]))

(defn as-response
  "Walk `entity` using the specified `schema` to decide which attributes to traverse. Use refs to specify
which attributes are expected to be datomic refs. The values returned for those refs will be transformed
via the :as-response key of the corresponding ref"
  [entity schema refs]
  (letfn [(walk-entity [entity schema]
            (reduce (fn [m [schema-name schema-type]]
                      (if (branch? schema-type)
                        (merge m {schema-name (walk-entity (schema-name entity)
                                                           {schema-name schema-type})})
                        (merge m (if-let [ref (find-referrer schema-name refs)]
                                   {schema-name ((:as-response ref) entity)}
                                   {schema-name (schema-name entity)}))))
                    {}
                    schema))]
    (walk-entity entity (seq schema))))


(defn as-facts
  "Generates datomic facts by recursively walking the specified map converting
(key val) -> [:db/add tmp-id attr val]

For any values that are themselves maps, we recur on the map and add a ref for
the current key"
  ([tmp-id object refs]
     (reduce (fn [acc [k v]]
               (if (branch? v)
                 (into acc (let [ref-id (d/tempid :db.part/user)
                                 ret (concat [[:db/add tmp-id k ref-id]]
                                             (as-facts ref-id (into {} v)))]
                             ret))
                 (into acc [[:db/add tmp-id k (if-let [ref (find-referrer k refs)]
                                                (condp instance? v
                                                  datomic.db.DbId v
                                                  ((:as-lookup-ref ref) v))
                                                v)]])))
             []
             (seq object)))
  ([objects]
     (mapcat (fn [obj]
               (as-facts (d/tempid :db.part/user) obj []))
             objects)))

(defn apply-tx
  "Apply a transaction against `c` using the facts generated by calling `as-facts` with `params`"
  [c facts]
  @(d/transact c facts))

(def ^{:private true} type-map
  {Str                      :db.type/string
   Bool                     :db.type/boolean
   Long                     :db.type/long
   ;java.Math.BigInteger     :db.type/bigint
   Num                      :db.type/double
   Int                      :db.type/long
   Float                    :db.type/float
   Inst                     :db.type/instant

   URI                      :db.type/string})

(defn datomic-schema
  "Generate datomic attributes for the specified resource.

If `uniqueness` is specified, it should be a hash where each key means
  the attribute with that name is marked as unique in datomic. The
  value can be used to determine the type of uniqueness. For details
  about the different types of uniqueness, refer to the datomic
  documentation which can be found at

http://docs.datomic.com/identity.html

`refs` should be a sequence of attributes which represent references
to other entities. For each ref, at attribute of type :db.type/ref will
be generated.

`storage-attrs` should be a sequence of attributes representing some sub-set
of the attributes listed in `schema`. You can use a map in place of an
attribute to perform a transform on that attribute before persisting it. If
the value is a map, it should have `:name` and `:callable` attributes."
  [schema uniqueness refs storage-attrs]
  (letfn [(storable? [k]
            (or (nil? storage-attrs)
                (some #{k} (map #(if (map? %) (:name %) %) storage-attrs))))

          (generate-ref [k v]
            (merge (generate-attr k v)
                   {:db/valueType :db.type/ref}))
          
          (generate-attr [k v]
            (let [cardinality (if (vector? v)
                                :db.cardinality/many :db.cardinality/one)
                  value-type (get type-map v :db.type/string)]
              (merge
               {:db/id (d/tempid :db.part/db)
                :db/ident k
                :db/valueType value-type
                :db/cardinality cardinality
                :db.install/_attribute :db.part/db}
               (if-let [uniq (k uniqueness)] {:db/unique uniq} {}))))

          (reducer [acc [k v]]
            (cond
             (find-referrer k refs)
             (into acc [(generate-ref k v)])

             (branch? v)
             (into acc (conj (generate-attrs (into {} v))
                             ((:attr-factory dat/Ref) k)))

             :else (if (storable? k)
                     (into acc [(generate-attr k v)])
                     acc)))
          
          (generate-attrs [schema]
            (reduce reducer [] (seq schema)))]
    (generate-attrs schema)))

(defn only
  "Return the only item from a query result"
  [query-result]
  (assert (= 1 (count query-result)))
  (assert (= 1 (count (first query-result))))
  (ffirst query-result))

(defn qe
  "Returns the single entity returned by a query."
  [query db & args]
  (let [res (apply d/q query db args)]
    (if (empty? res)
      nil
      (d/entity db (only res)))))

(defn find-by
  "Returns the unique entity identified by attr and val."
  [db attr val]
  (qe '[:find ?e
        :in $ ?attr ?val
        :where [?e ?attr ?val]]
      db (d/entid db attr) val))

;; HTTP Helpers
(defn get? [ctx]
  (= :get (get-in ctx [:request :request-method])))

(defn known-content-type? [ctx]
  (if (= "application/edn" (get-in ctx [:request :content-type]))
    true
    [false {:error "Unsupported content type"}]))

(defn coerce-id
  "Coerce the string-value of `id` to the type indicated by the :id attribute of `schema`"
  [schema id]
  (let [c (coercer (apply hash-map (find schema :id)) string-coercion-matcher)]
    (:id (c {:id id}))))

;; Schema Helpers
(defn build-ref
  "Builds a reference to the `referent` attribute of `resource` from the `referrer` attribute of
the current context"
  [resource referrer referent]
  {:referrer referrer
   :referent referent
   :resource resource
   :as-response (fn [entity]
                  (format "%s/%s"
                          (:name resource)
                          ((comp referent referrer) entity)))
   :as-lookup-ref (fn [uri]
                    (let [[_ id] (take-last 2 (clojure.string/split (.getPath (URI. uri)) #"/"))
                          coerce (coercer (apply hash-map (find (:schema resource) referent))
                                          string-coercion-matcher)]
                      [referent (referent (coerce {referent id}))]))})
      
(defn optionalize
  "Create a new schema from `schema` where all keys have been replaced with 'optional' versions of themselves"
  [schema]
  (into {} (map (fn [[name type]]
                  [(s/optional-key name) type])
                (seq schema))))

;;## CRUD Protocol
;;
;; This file defines the basic protocol for handling CRUD HTTP requests in a generic way. The "!" at the end of a
;; method name below indicates that it is likely to add new facts (or replace existing ones). Each of the functions
;; here return a function designed to be used in the liberator web-machine. That is, they accept a context map
;; containing the the HTTP request and response along with any other keys added by prior steps in the machine

(defn find-by-id
  "Return a liberator handler that finds the entity in `db` whose :id attribute is equal to `id`"
  [db schema id]
  (fn [ctx]
    (if-let [id (coerce-id schema id)]
      (if-let [entity (find-by db :id id)]
        [true (assoc-in ctx [:entity] entity)]
        [false (assoc-in ctx [::parsed-input :id] id)]))))

(defn- storable [object attrs]
  (let [reducer (fn [m [k v]]
                  (if (contains? object k)
                    (assoc m k v)
                    m))
        attr-reader (fn [attr]
                      (if (map? attr)
                        [(:name attr) ((:callable attr) ((:name attr) object))]
                        [attr (attr object)]))]
    (reduce reducer {} (map attr-reader attrs))))

(defn creator! [c refs storable-attrs]
  (fn [ctx]
    (apply-tx c (as-facts (d/tempid :db.part/user)
                          (storable (get-in ctx [::valid-parsed-input]) storable-attrs)
                          refs))))

(defn destroyer! [c]
  (fn [ctx]
    (if-let [e (:entity ctx)]
      (apply-tx c [[:db.fn/retractEntity (:db/id e)]])
      (throw (Exception. "wtf????"))))) 

(defn validator [schema]
  ;; TODO: This feels like a code smell. Other functions that use the validated input need
  ;; to know where we put it in the context (i.e. ::valid-parsed-input). Not sure how to fix
  ;; though
  (let [parsed-input-path [::parsed-input]
        valid-input-path [::valid-parsed-input]
        error-input-path [::validation-error]]
    (fn [ctx]
      (let [validate-with (fn [s]
                            (let [validator (coercer s string-coercion-matcher)
                                  validated (validator (get-in ctx parsed-input-path))]
                              (if (schema.utils/error? validated)
                                [false (assoc-in {} error-input-path validated)]
                                [true (assoc-in {} valid-input-path validated)])))]
        (if (get? ctx)
          (validate-with (optionalize schema))
          (validate-with schema))))))

(defn malformed? [reader responder]
  "Parses the request body and puts the result in the context key `::parsed-input`"
  (fn [ctx]
    (let [input-path [:request :body]
          output-path [::parsed-input]]
      (try
        (let [body-as-str (if-let [body (get-in ctx input-path)]
                            (condp instance? body
                              java.lang.String body
                              (slurp (clojure.java.io/reader body))))]
          [false (assoc-in {} output-path (reader body-as-str))])
        (catch RuntimeException e
          [true {:representation {:media-type responder}
                 :parser-error (.getLocalizedMessage e)}])))))

(def edn-malformed? (malformed? clojure.edn/read-string "application/edn"))

(defn redirector [ctx]
  "Used in POST requests to support replying with the location of a created resource"
  (let [request (get-in ctx [:request])]
    (URL. (format "%s://%s:%s%s/%s"
                  (name (:scheme request))
                  (:server-name request)
                  (:server-port request)
                  (:uri request)
                  (get-in ctx [::valid-parsed-input :id])))))

(defn handler [db cardinality resource]
  "Used to generate responses to GET requests for `resource`"
  (let [{:keys [schema refs]} resource
        input-path [::valid-parsed-input]
        handle (fn [e] (as-response e schema refs))]
    (fn [ctx]
      (let [entities (find-entities db (get-in ctx input-path))]
        (case cardinality
          :collection (into [] (map handle entities))
          :single (handle (first entities)))))))

(defn with-id [id]
  (fn [ctx]
    (assoc-in ctx [::parsed-input :id] id)))

(defn entity-not-found? [ctx]
  (not (:entity ctx)))

(defn handle-not-found [name id]
  (fn [ctx]
    {:error (str "Could not find " name " with id: " id)}))

(def handle-malformed
  (fn [ctx]
    {:error (:parser-error ctx)}))

(defn handle-ok [schema refs]
  (fn [ctx]
    (as-response (:entity ctx) schema refs)))

(defn api-routes
  "Return ring handlers for the specified `entitity`. The entity is a hash that may contain the following
keys:-

:name (required)
Is the name of this entity. This will be part of the URI of any generated resources

:schema (required)
Is a prismatic schema definition listing the desired attributes and whether they are required

:uniqueness (required)
Is a map representing the uniqueness constraints of the attributes specified by schema. Each key
should be a key in schema. Each value should be a datomic uniqueness type

:storable (optional)
Is an array representing which attributes should actually be persisted to the database. Each value
is either a keyword, or a map. If the value is a keyword, it means the corresponding value in the
request will be persisted. If the value is a map, it should have :name and :callable keys. The
name is simply the name of the attribute to be saved, :callable is a function which may transform
the value before persisting it to the database.
  "
 [cnx entity]
  (let [{:keys [name schema uniqueness refs]} entity
        with-overrides (fn [& b] (merge (apply hash-map b) entity))
        db (d/db cnx)
        storable (or (:storable entity)
                     (keys schema))]
    (http/routes
     ;; a collection of resources can be queried, or appended to
     (http/ANY "/" []
       (rest/resource
        (with-overrides
          :available-media-types ["application/edn"]
          :allowed-methods       [:get :post]
          :known-content-type?   known-content-type?
          :malformed?            edn-malformed?
          :processable?          (validator schema)
          :post!                 (creator! cnx refs storable)
          :post-redirect         true
          :location              redirector
          :handle-ok             (handler db :collection entity)
          :handle-created        (pr-str "Created.")
          :handle-unprocessable-entity (comp schema.utils/error-val ::validation-error))))

     (http/GET "/:id" [id]
       (rest/resource
        (with-overrides
          :allowed-methods              [:get]
          :available-media-types        ["application/edn"]
          :known-content-type?          known-content-type?
          :exists?                      (find-by-id db schema id)
          :handle-not-found             (handle-not-found name id)
          :handle-ok                    (handle-ok schema refs))))

     (http/PUT "/:id" [id]
       (rest/resource
        (with-overrides
          :allowed-methods       [:put]
          :available-media-types ["application/edn"]
          :known-content-type?   known-content-type?
          :malformed?            edn-malformed?
          :processable?          (comp (validator schema) (with-id id))
          :exists?               (find-by-id db schema id)
          :new?                  entity-not-found?
          :can-put-to-missing?   true
          :put!                  (creator! cnx refs storable)
          :handle-malformed      handle-malformed
          :handle-created        (pr-str "Created.")
          :handle-unprocessable-entity (comp schema.utils/error-val ::validation-error))))

     (http/PATCH "/:id" [id]
       (rest/resource
        (with-overrides
          :allowed-methods       [:patch]
          :available-media-types ["application/edn"]
          :known-content-type?   known-content-type?
          :malformed?            edn-malformed?
          :processable?          (comp (validator (optionalize schema)) (with-id id))
          :exists?               (find-by-id db schema id) 
          :handle-not-found      (handle-not-found name id)
          :patch!                (creator! cnx refs storable)
          :handle-malformed      handle-malformed
          :handle-unprocessable-entity (comp schema.utils/error-val ::validation-error))))
     
     (http/DELETE "/:id" [id]
       (rest/resource
        (with-overrides
          :allowed-methods       [:delete]
          :available-media-types ["application/edn"]
          :known-content-type?   known-content-type?
          :exists?               (find-by-id db schema id)
          :delete!               (destroyer! cnx)
          :handle-not-found      (handle-not-found name id)
          :handle-no-content     (pr-str "Deleted.")))))))
